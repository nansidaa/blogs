(window.webpackJsonp=window.webpackJsonp||[]).push([[101],{566:function(e,t,s){"use strict";s.r(t);var o=s(2),n=Object(o.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("blockquote",[t("p",[e._v("⛺️ vite 就是安装就可以用的（开箱即用（out of box ））不需要做任何额外的依赖就可以用 vite 构建工具来处理构建工作 如果没有安装 vite 之前，浏览器是不会识别相对路径和绝对路径下的依赖。安装 vite 以后 vite 会对这些相对路径和绝对路径下的配置 进行路径补全 例如 node"),t("em",[e._v("modules/.vite/**")]),e._v("/_**? 浏览器就会识别所需依赖"),t("br"),e._v("\n⛺️ vite 搜寻依赖的过程是从当前目录向上查找的过程，直至搜寻到根目录或者查找到对应的依赖为止"),t("br"),e._v("\n⛺️ yarn dev 是生产环境运行（每次依赖预构建所重新构建的依赖相对路径都是正确的）"),t("br"),e._v("\n⛺️ 生产环境 vite 会全权交给一个 rollup 的库去完成生产环境的打包（会兼容很多场景和环境和规范）"),t("br"),e._v("\n⛺️ 有的项目会用不同的规范 如果不是 esmodules 规范的话 vite 就不识别 浏览器就不会编译 例如（common js(module.exports)规范导出的就不会识别）这种就要用到依赖预构建：（首先 vite 会找到对应的依赖，然后调用 esbuild（是对 js 语法进行处理的一个库)：会将其他规范代码转换成 esmodules 规范的代码，然后放在当前目录下的：node_modules/.vite/deps,同时对 esmodule 规范各个模块进行统一集成）")])]),e._v(" "),t("div",{staticClass:"language-javascript extra-class"},[t("pre",{pre:!0,attrs:{class:"language-javascript"}},[t("code",[e._v("optimizeDeps："),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\nexclude：【‘xxxxx’】是将xxxxx不用于依赖预构建（exclude  vite方法）\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),t("blockquote",[t("p",[e._v("⛺️ 1.解决了第三方包会有不同的导出格式（会将其他到出的格式全部转换为esmodules规范格式）"),t("br"),e._v("\n⛺️ 2.在路径的处理上可以直接使用 .vite/deps, 都会集成到这个目录下，方便路径重写（这样子就可以不用在意路径是绝对路径还是相对路径的问题了）"),t("br"),e._v("\n⛺️ 3.解决网络多包传输的性能问题（是原生esmodules规范不敢支持node_module的原因之一)，有了依赖预构建以后无论他有多少export，import vite都会尽可能将他集成到一个模块或者几个模块。不然一个模块中会存在很多个 然后所有全部都加载一边，性能会很差。\\")])])])}),[],!1,null,null,null);t.default=n.exports}}]);